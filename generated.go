// This file is generated by the ./internal/gen command -- do not edit!

package pshgo

import (
	"encoding/base64"
	"encoding/json"
	"fmt"

	errors "github.com/pkg/errors"
	logrus "github.com/sirupsen/logrus"
)

type AccessLevel uint8

const (
	AccessLevelViewer AccessLevel = iota
	AccessLevelContributor
	AccessLevelAdmin
	totalAccessLevels
)

var (
	accessLevels = [totalAccessLevels]string{
		"viewer",
		"contributor",
		"admin",
	}

	accessLevelsMap = map[string]AccessLevel{
		"viewer":      AccessLevelViewer,
		"contributor": AccessLevelContributor,
		"admin":       AccessLevelAdmin,
	}
)

func NewAccessLevel(name string) (AccessLevel, error) {
	if v, ok := accessLevelsMap[name]; ok {
		return v, nil
	}

	return 0, fmt.Errorf("unknown AccessLevel name %q", name)
}

func (v AccessLevel) String() string {
	if v < totalAccessLevels {
		return accessLevels[v]
	}

	return fmt.Sprintf("unknown AccessLevel value %02x", uint8(v))
}

func (v *AccessLevel) UnmarshalText(text []byte) (err error) {
	*v, err = NewAccessLevel(string(text))
	return err
}

func (v AccessLevel) MarshalText() ([]byte, error) {
	if v < totalAccessLevels {
		return []byte(accessLevels[v]), nil
	}

	return nil, errors.New(v.String())
}

type AccessType uint8

const (
	AccessTypeSSH AccessType = iota
	totalAccessTypes
)

var (
	accessTypes = [totalAccessTypes]string{
		"ssh",
	}

	accessTypesMap = map[string]AccessType{
		"ssh": AccessTypeSSH,
	}
)

func NewAccessType(name string) (AccessType, error) {
	if v, ok := accessTypesMap[name]; ok {
		return v, nil
	}

	return 0, fmt.Errorf("unknown AccessType name %q", name)
}

func (v AccessType) String() string {
	if v < totalAccessTypes {
		return accessTypes[v]
	}

	return fmt.Sprintf("unknown AccessType value %02x", uint8(v))
}

func (v *AccessType) UnmarshalText(text []byte) (err error) {
	*v, err = NewAccessType(string(text))
	return err
}

func (v AccessType) MarshalText() ([]byte, error) {
	if v < totalAccessTypes {
		return []byte(accessTypes[v]), nil
	}

	return nil, errors.New(v.String())
}

type ApplicationMount uint8

const (
	ApplicationMountLocal ApplicationMount = iota
	ApplicationMountTemp
	ApplicationMountService
	totalApplicationMounts
)

var (
	applicationMounts = [totalApplicationMounts]string{
		"local",
		"tmp",
		"service",
	}

	applicationMountsMap = map[string]ApplicationMount{
		"local":   ApplicationMountLocal,
		"tmp":     ApplicationMountTemp,
		"service": ApplicationMountService,
	}
)

func NewApplicationMount(name string) (ApplicationMount, error) {
	if v, ok := applicationMountsMap[name]; ok {
		return v, nil
	}

	return 0, fmt.Errorf("unknown ApplicationMount name %q", name)
}

func (v ApplicationMount) String() string {
	if v < totalApplicationMounts {
		return applicationMounts[v]
	}

	return fmt.Sprintf("unknown ApplicationMount value %02x", uint8(v))
}

func (v *ApplicationMount) UnmarshalText(text []byte) (err error) {
	*v, err = NewApplicationMount(string(text))
	return err
}

func (v ApplicationMount) MarshalText() ([]byte, error) {
	if v < totalApplicationMounts {
		return []byte(applicationMounts[v]), nil
	}

	return nil, errors.New(v.String())
}

type ServiceSize uint8

const (
	ServiceSizeAuto ServiceSize = iota
	ServiceSizeSmall
	ServiceSizeMedium
	ServiceSizeLarge
	ServiceSizeExtraLarge
	ServiceSizeDoubleExtraLarge
	ServiceSizeQuadrupleExtraLarge
	totalServiceSizes
)

var (
	serviceSizes = [totalServiceSizes]string{
		"AUTO",
		"S",
		"M",
		"L",
		"XL",
		"2XL",
		"4XL",
	}

	serviceSizesMap = map[string]ServiceSize{
		"AUTO": ServiceSizeAuto,
		"S":    ServiceSizeSmall,
		"M":    ServiceSizeMedium,
		"L":    ServiceSizeLarge,
		"XL":   ServiceSizeExtraLarge,
		"2XL":  ServiceSizeDoubleExtraLarge,
		"4XL":  ServiceSizeQuadrupleExtraLarge,
	}
)

func NewServiceSize(name string) (ServiceSize, error) {
	if v, ok := serviceSizesMap[name]; ok {
		return v, nil
	}

	return 0, fmt.Errorf("unknown ServiceSize name %q", name)
}

func (v ServiceSize) String() string {
	if v < totalServiceSizes {
		return serviceSizes[v]
	}

	return fmt.Sprintf("unknown ServiceSize value %02x", uint8(v))
}

func (v *ServiceSize) UnmarshalText(text []byte) (err error) {
	*v, err = NewServiceSize(string(text))
	return err
}

func (v ServiceSize) MarshalText() ([]byte, error) {
	if v < totalServiceSizes {
		return []byte(serviceSizes[v]), nil
	}

	return nil, errors.New(v.String())
}

type SocketFamily uint8

const (
	SocketFamilyTCP SocketFamily = iota
	SocketFamilyUnix
	totalSocketFamilies
)

var (
	socketFamilies = [totalSocketFamilies]string{
		"tcp",
		"unix",
	}

	socketFamiliesMap = map[string]SocketFamily{
		"tcp":  SocketFamilyTCP,
		"unix": SocketFamilyUnix,
	}
)

func NewSocketFamily(name string) (SocketFamily, error) {
	if v, ok := socketFamiliesMap[name]; ok {
		return v, nil
	}

	return 0, fmt.Errorf("unknown SocketFamily name %q", name)
}

func (v SocketFamily) String() string {
	if v < totalSocketFamilies {
		return socketFamilies[v]
	}

	return fmt.Sprintf("unknown SocketFamily value %02x", uint8(v))
}

func (v *SocketFamily) UnmarshalText(text []byte) (err error) {
	*v, err = NewSocketFamily(string(text))
	return err
}

func (v SocketFamily) MarshalText() ([]byte, error) {
	if v < totalSocketFamilies {
		return []byte(socketFamilies[v]), nil
	}

	return nil, errors.New(v.String())
}

type SocketProtocol uint8

const (
	SocketProtocolHTTP SocketProtocol = iota
	SocketProtocolFastCGI
	SocketProtocolUWSGI
	totalSocketProtocols
)

var (
	socketProtocols = [totalSocketProtocols]string{
		"http",
		"fastcgi",
		"uwsgi",
	}

	socketProtocolsMap = map[string]SocketProtocol{
		"http":    SocketProtocolHTTP,
		"fastcgi": SocketProtocolFastCGI,
		"uwsgi":   SocketProtocolUWSGI,
	}
)

func NewSocketProtocol(name string) (SocketProtocol, error) {
	if v, ok := socketProtocolsMap[name]; ok {
		return v, nil
	}

	return 0, fmt.Errorf("unknown SocketProtocol name %q", name)
}

func (v SocketProtocol) String() string {
	if v < totalSocketProtocols {
		return socketProtocols[v]
	}

	return fmt.Sprintf("unknown SocketProtocol value %02x", uint8(v))
}

func (v *SocketProtocol) UnmarshalText(text []byte) (err error) {
	*v, err = NewSocketProtocol(string(text))
	return err
}

func (v SocketProtocol) MarshalText() ([]byte, error) {
	if v < totalSocketProtocols {
		return []byte(socketProtocols[v]), nil
	}

	return nil, errors.New(v.String())
}

func LookupApplication(p PlatformProvider) (*Application, bool) {
	name := p.Prefix() + "APPLICATION"
	value, ok := p.Lookup(name)
	if !ok {
		return nil, false
	}
	data, err := base64.StdEncoding.DecodeString(value)
	if err != nil {
		logrus.WithError(err).Warn("unable to decode value")
		return nil, false
	}
	obj := Application{}
	err = json.Unmarshal(data, &obj)
	if err != nil {
		logrus.WithError(err).Warn("unable to unmarshal value")
		return nil, false
	}
	return &obj, true
}

func GetApplication(p PlatformProvider) *Application {
	v, _ := LookupApplication(p)
	return v
}

func (e *Environment) LookupApplication() (*Application, bool) {
	return LookupApplication(e)
}

func (e *Environment) GetApplication() *Application {
	return GetApplication(e)
}

func LookupApplicationName(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "APPLICATION_NAME"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetApplicationName(p PlatformProvider) string {
	v, _ := LookupApplicationName(p)
	return v
}

func (e *Environment) LookupApplicationName() (string, bool) {
	return LookupApplicationName(e)
}

func (e *Environment) GetApplicationName() string {
	return GetApplicationName(e)
}

func LookupAppName(p PlatformProvider) (string, bool) {
	return LookupApplicationName(p)
}

func GetAppName(p PlatformProvider) string {
	return GetApplicationName(p)
}

func (e *Environment) LookupAppName() (string, bool) {
	return LookupAppName(e)
}

func (e *Environment) GetAppName() string {
	return GetAppName(e)
}

func LookupAppCommand(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "APP_COMMAND"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetAppCommand(p PlatformProvider) string {
	v, _ := LookupAppCommand(p)
	return v
}

func (e *Environment) LookupAppCommand() (string, bool) {
	return LookupAppCommand(e)
}

func (e *Environment) GetAppCommand() string {
	return GetAppCommand(e)
}

func LookupApplicationCommand(p PlatformProvider) (string, bool) {
	return LookupAppCommand(p)
}

func GetApplicationCommand(p PlatformProvider) string {
	return GetAppCommand(p)
}

func (e *Environment) LookupApplicationCommand() (string, bool) {
	return LookupApplicationCommand(e)
}

func (e *Environment) GetApplicationCommand() string {
	return GetApplicationCommand(e)
}

func LookupAppDir(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "APP_DIR"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetAppDir(p PlatformProvider) string {
	v, _ := LookupAppDir(p)
	return v
}

func (e *Environment) LookupAppDir() (string, bool) {
	return LookupAppDir(e)
}

func (e *Environment) GetAppDir() string {
	return GetAppDir(e)
}

func LookupBranch(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "BRANCH"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetBranch(p PlatformProvider) string {
	v, _ := LookupBranch(p)
	return v
}

func (e *Environment) LookupBranch() (string, bool) {
	return LookupBranch(e)
}

func (e *Environment) GetBranch() string {
	return GetBranch(e)
}

func LookupDir(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "DIR"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetDir(p PlatformProvider) string {
	v, _ := LookupDir(p)
	return v
}

func (e *Environment) LookupDir() (string, bool) {
	return LookupDir(e)
}

func (e *Environment) GetDir() string {
	return GetDir(e)
}

func LookupDocumentRoot(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "DOCUMENT_ROOT"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetDocumentRoot(p PlatformProvider) string {
	v, _ := LookupDocumentRoot(p)
	return v
}

func (e *Environment) LookupDocumentRoot() (string, bool) {
	return LookupDocumentRoot(e)
}

func (e *Environment) GetDocumentRoot() string {
	return GetDocumentRoot(e)
}

func LookupEnvironment(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "ENVIRONMENT"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetEnvironment(p PlatformProvider) string {
	v, _ := LookupEnvironment(p)
	return v
}

func (e *Environment) LookupEnvironment() (string, bool) {
	return LookupEnvironment(e)
}

func (e *Environment) GetEnvironment() string {
	return GetEnvironment(e)
}

func LookupPort(p PlatformProvider) (string, bool) {
	name := "PORT"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetPort(p PlatformProvider) string {
	v, _ := LookupPort(p)
	return v
}

func (e *Environment) LookupPort() (string, bool) {
	return LookupPort(e)
}

func (e *Environment) GetPort() string {
	return GetPort(e)
}

func LookupProject(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "PROJECT"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetProject(p PlatformProvider) string {
	v, _ := LookupProject(p)
	return v
}

func (e *Environment) LookupProject() (string, bool) {
	return LookupProject(e)
}

func (e *Environment) GetProject() string {
	return GetProject(e)
}

func LookupProjectEntropy(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "PROJECT_ENTROPY"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetProjectEntropy(p PlatformProvider) string {
	v, _ := LookupProjectEntropy(p)
	return v
}

func (e *Environment) LookupProjectEntropy() (string, bool) {
	return LookupProjectEntropy(e)
}

func (e *Environment) GetProjectEntropy() string {
	return GetProjectEntropy(e)
}

func LookupRelationships(p PlatformProvider) (Relationships, bool) {
	name := p.Prefix() + "RELATIONSHIPS"
	value, ok := p.Lookup(name)
	if !ok {
		return nil, false
	}
	data, err := base64.StdEncoding.DecodeString(value)
	if err != nil {
		logrus.WithError(err).Warn("unable to decode value")
		return nil, false
	}
	obj := Relationships{}
	err = json.Unmarshal(data, &obj)
	if err != nil {
		logrus.WithError(err).Warn("unable to unmarshal value")
		return nil, false
	}
	return obj, true
}

func GetRelationships(p PlatformProvider) Relationships {
	v, _ := LookupRelationships(p)
	return v
}

func (e *Environment) LookupRelationships() (Relationships, bool) {
	return LookupRelationships(e)
}

func (e *Environment) GetRelationships() Relationships {
	return GetRelationships(e)
}

func LookupRoutes(p PlatformProvider) (Routes, bool) {
	name := p.Prefix() + "ROUTES"
	value, ok := p.Lookup(name)
	if !ok {
		return nil, false
	}
	data, err := base64.StdEncoding.DecodeString(value)
	if err != nil {
		logrus.WithError(err).Warn("unable to decode value")
		return nil, false
	}
	obj := Routes{}
	err = json.Unmarshal(data, &obj)
	if err != nil {
		logrus.WithError(err).Warn("unable to unmarshal value")
		return nil, false
	}
	return obj, true
}

func GetRoutes(p PlatformProvider) Routes {
	v, _ := LookupRoutes(p)
	return v
}

func (e *Environment) LookupRoutes() (Routes, bool) {
	return LookupRoutes(e)
}

func (e *Environment) GetRoutes() Routes {
	return GetRoutes(e)
}

func LookupSMTPHost(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "SMTP_HOST"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetSMTPHost(p PlatformProvider) string {
	v, _ := LookupSMTPHost(p)
	return v
}

func (e *Environment) LookupSMTPHost() (string, bool) {
	return LookupSMTPHost(e)
}

func (e *Environment) GetSMTPHost() string {
	return GetSMTPHost(e)
}

func LookupSocket(p PlatformProvider) (string, bool) {
	name := "SOCKET"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetSocket(p PlatformProvider) string {
	v, _ := LookupSocket(p)
	return v
}

func (e *Environment) LookupSocket() (string, bool) {
	return LookupSocket(e)
}

func (e *Environment) GetSocket() string {
	return GetSocket(e)
}

func LookupTreeID(p PlatformProvider) (string, bool) {
	name := p.Prefix() + "TREE_ID"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetTreeID(p PlatformProvider) string {
	v, _ := LookupTreeID(p)
	return v
}

func (e *Environment) LookupTreeID() (string, bool) {
	return LookupTreeID(e)
}

func (e *Environment) GetTreeID() string {
	return GetTreeID(e)
}

func LookupVariables(p PlatformProvider) (Variables, bool) {
	name := p.Prefix() + "VARIABLES"
	value, ok := p.Lookup(name)
	if !ok {
		return nil, false
	}
	data, err := base64.StdEncoding.DecodeString(value)
	if err != nil {
		logrus.WithError(err).Warn("unable to decode value")
		return nil, false
	}
	obj := Variables{}
	err = json.Unmarshal(data, &obj)
	if err != nil {
		logrus.WithError(err).Warn("unable to unmarshal value")
		return nil, false
	}
	return obj, true
}

func GetVariables(p PlatformProvider) Variables {
	v, _ := LookupVariables(p)
	return v
}

func (e *Environment) LookupVariables() (Variables, bool) {
	return LookupVariables(e)
}

func (e *Environment) GetVariables() Variables {
	return GetVariables(e)
}

func LookupVars(p PlatformProvider) (Variables, bool) {
	return LookupVariables(p)
}

func GetVars(p PlatformProvider) Variables {
	return GetVariables(p)
}

func (e *Environment) LookupVars() (Variables, bool) {
	return LookupVars(e)
}

func (e *Environment) GetVars() Variables {
	return GetVars(e)
}

func LookupXClientCert(p PlatformProvider) (string, bool) {
	name := "X_CLIENT_CERT"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetXClientCert(p PlatformProvider) string {
	v, _ := LookupXClientCert(p)
	return v
}

func (e *Environment) LookupXClientCert() (string, bool) {
	return LookupXClientCert(e)
}

func (e *Environment) GetXClientCert() string {
	return GetXClientCert(e)
}

func LookupXClientDN(p PlatformProvider) (string, bool) {
	name := "X_CLIENT_DN"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetXClientDN(p PlatformProvider) string {
	v, _ := LookupXClientDN(p)
	return v
}

func (e *Environment) LookupXClientDN() (string, bool) {
	return LookupXClientDN(e)
}

func (e *Environment) GetXClientDN() string {
	return GetXClientDN(e)
}

func LookupXClientIP(p PlatformProvider) (string, bool) {
	name := "X_CLIENT_IP"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetXClientIP(p PlatformProvider) string {
	v, _ := LookupXClientIP(p)
	return v
}

func (e *Environment) LookupXClientIP() (string, bool) {
	return LookupXClientIP(e)
}

func (e *Environment) GetXClientIP() string {
	return GetXClientIP(e)
}

func LookupXClientVerify(p PlatformProvider) (string, bool) {
	name := "X_CLIENT_VERIFY"
	value, ok := p.Lookup(name)
	return value, ok
}

func GetXClientVerify(p PlatformProvider) string {
	v, _ := LookupXClientVerify(p)
	return v
}

func (e *Environment) LookupXClientVerify() (string, bool) {
	return LookupXClientVerify(e)
}

func (e *Environment) GetXClientVerify() string {
	return GetXClientVerify(e)
}
